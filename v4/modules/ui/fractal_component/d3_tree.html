<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100vh;
            overflow: auto;
            background-color: #0f172a;
            font-family: 'Inter', Arial, sans-serif;
        }

        #tree-container {
            width: 100%;
            min-height: 1200px;
            padding: 0;
        }

        .node rect {
            cursor: pointer;
            stroke: #1e293b;
            stroke-width: 2px;
            transition: all 0.2s ease;
        }

        .node.selected rect {
            stroke: #9333ea;
            stroke-width: 4px;
            filter: brightness(1.2);
        }

        .node text {
            font-size: 13px;
            fill: white;
            pointer-events: none;
            font-weight: 600;
        }

        .node text.amount {
            fill: #22d3ee;
            font-size: 12px;
        }

        .link {
            fill: none;
            stroke: #64748b;
            stroke-width: 3px;
            opacity: 0.7;
        }

        .node:hover rect {
            filter: brightness(1.4);
            stroke-width: 3px;
        }
    </style>
</head>

<body>
    <div id="tree-container"></div>

    <!-- D3.js v7 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
        let selectedCodes = new Set();
        let hierarchyData = null;

        window.addEventListener('message', function (event) {
            if (event.data && event.data.hierarchy) {
                hierarchyData = event.data.hierarchy;
                renderTree(hierarchyData);
            }
        });

        window.parent.postMessage({ type: 'request-data' }, '*');

        function renderTree(hierarchy) {
            if (!hierarchy) return;

            d3.select('#tree-container').selectAll('*').remove();

            const root = convertToD3Hierarchy(hierarchy);

            // Container dimensions
            const containerWidth = Math.max(window.innerWidth, 1400);
            const containerHeight = Math.max(window.innerHeight, 1200);

            // Tree dimensions (slightly smaller for padding)
            const treeWidth = containerWidth * 0.9;
            const treeHeight = containerHeight * 0.85;

            const treeLayout = d3.tree()
                .size([treeWidth, treeHeight])
                .separation((a, b) => (a.parent == b.parent ? 1.2 : 1.5));

            const treeData = treeLayout(root);

            const svg = d3.select('#tree-container')
                .append('svg')
                .attr('width', containerWidth)
                .attr('height', containerHeight);

            // CENTER THE TREE
            const offsetX = (containerWidth - treeWidth) / 2;
            const offsetY = 80;

            const g = svg.append('g')
                .attr('transform', `translate(${offsetX}, ${offsetY})`);

            // Branches
            g.selectAll('.link')
                .data(treeData.links())
                .enter()
                .append('path')
                .attr('class', 'link')
                .attr('d', d3.linkVertical()
                    .x(d => d.x)
                    .y(d => d.y)
                );

            // Nodes
            const nodes = g.selectAll('.node')
                .data(treeData.descendants())
                .enter()
                .append('g')
                .attr('class', d => `node ${selectedCodes.has(d.data.code) ? 'selected' : ''}`)
                .attr('transform', d => `translate(${d.x}, ${d.y})`)
                .on('click', function (event, d) {
                    handleNodeClick(d);
                });

            // Rectangles
            nodes.append('rect')
                .attr('x', -80)
                .attr('y', -30)
                .attr('width', 160)
                .attr('height', 60)
                .attr('rx', 8)
                .attr('fill', d => {
                    if (selectedCodes.has(d.data.code)) return '#9333ea';
                    return d.data.color || '#64748b';
                });

            // Labels
            nodes.append('text')
                .attr('dy', -10)
                .attr('text-anchor', 'middle')
                .text(d => {
                    const label = d.data.label || d.data.code;
                    return label.length > 16 ? label.substring(0, 16) + '...' : label;
                });

            // Amounts
            nodes.append('text')
                .attr('class', 'amount')
                .attr('dy', 15)
                .attr('text-anchor', 'middle')
                .text(d => {
                    const amount = d.data.amount || d.data.total || 0;
                    return `${Math.abs(amount).toLocaleString('fr-FR', { maximumFractionDigits: 0 })} â‚¬`;
                });
        }

        function handleNodeClick(nodeData) {
            const code = nodeData.data.code;

            if (code === 'TR') {
                selectedCodes.clear();
                renderTree(hierarchyData);
                sendSelection();
                return;
            }

            if (selectedCodes.has(code)) {
                selectedCodes.delete(code);
            } else {
                selectedCodes.add(code);
            }

            renderTree(hierarchyData);
            sendSelection();
        }

        function sendSelection() {
            window.parent.postMessage({
                type: 'selection-changed',
                codes: Array.from(selectedCodes)
            }, '*');
        }

        function convertToD3Hierarchy(flatHierarchy) {
            const buildNode = (code) => {
                if (!flatHierarchy[code]) return null;

                const node = flatHierarchy[code];
                const children = (node.children || [])
                    .map(childCode => buildNode(childCode))
                    .filter(child => child !== null);

                return {
                    code: code,
                    label: node.label,
                    color: node.color,
                    amount: node.amount || node.total,
                    children: children.length > 0 ? children : undefined
                };
            };

            const treeData = buildNode('TR');
            return d3.hierarchy(treeData);
        }
    </script>
</body>

</html>